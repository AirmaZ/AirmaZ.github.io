<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>朱宏伟的前端笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="朱宏伟的前端笔记">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="朱宏伟的前端笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="朱宏伟的前端笔记">
  
    <link rel="alternate" href="/atom.xml" title="朱宏伟的前端笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">朱宏伟的前端笔记</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-深入了解webpack" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/19/深入了解webpack/" class="article-date">
  <time datetime="2016-09-19T06:55:26.000Z" itemprop="datePublished">2016-09-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/19/深入了解webpack/">深入了解webpack</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="# 前言">前言</a></li>
<li><a href="# Webpack安装">Webpack安装</a></li>
<li><a href="# Webpack核心原理">Webpack核心原理</a></li>
<li><a href="# webpack功能">webpack功能</a><ul>
<li><a href="# 1.开发模式和生产模式">开发模式和生产模式</a></li>
<li><a href="# 2.webpack CLI 和webpack-dev-server">webpack CLI 和webpack-dev-server</a></li>
</ul>
</li>
<li><a href="# 相关配置字段解析">相关配置字段解析</a><ul>
<li><a href="# 1.entry">entry</a></li>
<li><a href="# 2.output">output</a></li>
<li><a href="# 3.module &amp; loaders">module &amp; loaders</a></li>
<li><a href="# 4.plugins">plugins</a></li>
<li><a href="# 5.resolve">resolve</a></li>
</ul>
</li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>webpack是近期最火的一款模块加载器兼打包工具，它能把各种资源，例如JS（含JSX）、coffee、样式（含less/sass）、图片等都作为模块来使用和处理。</p>
<p>当前现在网上也有很多webpack的讲解，但都是些傻瓜式的配置教程，没有对webpack其中<code>webpack.config.js</code>中的字段进行详细的解释，以至于很多同学只是会只用别人配置好的项目，没有独立diy的能力。所以本文将从webpack的安装、核心原理、功能说明、配置字段解析这几个大方向来教大家学会如何使用webpack。</p>
<h2 id="Webpack安装"><a href="#Webpack安装" class="headerlink" title="Webpack安装"></a>Webpack安装</h2><ol>
<li>Webpack很多功能都依赖于node.js环境，所以在使用webpack前你的电脑上必须要有node.js+npm，至于这两者如何安装配置我就不说了，不在本文讨论范围内，网上有很多现成的教学。</li>
<li>安装分为全局安装和非全局，我们建议非全局安装的方式<ul>
<li>全局：我们常规直接使用 npm 的形式来安装Webpack：<code>$ npm install webpack -g</code></li>
<li>非全局：正常情况下我们都会将依赖写入<code>package.json</code>，然后执行初始化命令：<code>$ npm init</code>，安装webpack：<code>$ npm install webpack --save-dev</code>。</li>
</ul>
</li>
</ol>
<h2 id="Webpack核心原理"><a href="#Webpack核心原理" class="headerlink" title="Webpack核心原理"></a>Webpack核心原理</h2><p>webpack有两大核心原理：</p>
<ol>
<li>一切皆模块<br>正如js文件可以是一个“模块（module）”一样，其他的（如css、image或html）文件也可视作模 块。因此，你可以<code>require(&#39;myJSfile.js&#39;)</code>亦可以<code>require(&#39;myCSSfile.css&#39;)</code>。这意味着我们可以将事物（业务）分割成更小的易于管理的片段，从而达到重复利用等的目的。</li>
<li>按需加载<br>传统的模块打包工具（module bundlers）最终将所有的模块编译生成一个庞大的bundle.js文件。但是在真实的app里边，“bundle.js”文件可能有10M到15M之大可能会导致应用一直处于加载中状态。因此Webpack使用许多特性来分割代码然后生成多个“bundle”文件，而且异步加载部分代码以实现按需加载。</li>
</ol>
<h2 id="webpack功能"><a href="#webpack功能" class="headerlink" title="webpack功能"></a>webpack功能</h2><h3 id="1-开发模式和生产模式"><a href="#1-开发模式和生产模式" class="headerlink" title="1.开发模式和生产模式"></a>1.开发模式和生产模式</h3><p>首先要知道的是Webpack有许许多多的特性，一些是”开发模式“下才有的，一些是”生产模式“下才有的，还有一些是两种模式下都有的：</p>
<p><img src="http://i.imgur.com/AMYCGhZ.png" alt="开发模式和生产模式"></p>
<p>例如：</p>
<blockquote>
<p>为了生成bundles文件你可能在package.json文件加入如下的scripts项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">  // 运行npm run build 来编译生成生产模式下的bundles</div><div class="line">  &quot;build&quot;: &quot;webpack --config webpack.config.prod.js&quot;,</div><div class="line">  // 运行npm run dev来生成开发模式下的bundles以及启动本地server</div><div class="line">  &quot;dev&quot;: &quot;webpack-dev-server&quot;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="2-webpack-CLI-和webpack-dev-server"><a href="#2-webpack-CLI-和webpack-dev-server" class="headerlink" title="2.webpack CLI 和webpack-dev-server"></a>2.webpack CLI 和webpack-dev-server</h3><p>Webpack为用户提供两种交互接口：</p>
<ol>
<li>Webpack CLI tool：默认的交互方式（已随Webpack本身安装到本地）</li>
<li>webpack-dev-server：一个Node.js服务器（需要开发者从npm自行安装）</li>
</ol>
<h5 id="Webpack-CLI（有利于生产模式下打包）"><a href="#Webpack-CLI（有利于生产模式下打包）" class="headerlink" title="Webpack CLI（有利于生产模式下打包）"></a><em>Webpack CLI（有利于生产模式下打包）</em></h5><p>用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">方式1: </div><div class="line">// 全局模式安装webpack</div><div class="line">npm install webpack --g</div><div class="line">// 在终端输入</div><div class="line">$ webpack // &lt;--使用webpack.config.js生成bundle</div><div class="line">方式 2 :</div><div class="line">// 非全局模式安装webpack然后添加到package.json依赖里边</div><div class="line">npm install webpack --save</div><div class="line">// 添加build命令到package.json的scripts配置项</div><div class="line">&quot;scripts&quot;: &#123;</div><div class="line"> &quot;build&quot;: &quot;webpack --config webpack.config.prod.js -p&quot;,</div><div class="line"> ...</div><div class="line"> &#125;</div><div class="line">// 用法：</div><div class="line">&quot;npm run build&quot;</div></pre></td></tr></table></figure></p>
<h5 id="webpack-dev-server（有利于在开发模式下编译）"><a href="#webpack-dev-server（有利于在开发模式下编译）" class="headerlink" title="webpack-dev-server（有利于在开发模式下编译）"></a><em>webpack-dev-server（有利于在开发模式下编译）</em></h5><p>这是一个基于Express.js框架开发的web server，默认监听8080端口。server内部调用Webpack，这样做的好处是提供了额外的功能如热更新“Live Reload”以及热替换“Hot Module Replacement”（即HMR）。</p>
<ol>
<li><p>用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">方式 1:</div><div class="line">// 全局安装</div><div class="line">npm install webpack-dev-server --save</div><div class="line">// 终端输入</div><div class="line">$ webpack-dev-server --inline --hot</div><div class="line">用法 2:</div><div class="line">// 添加到package.json scripts</div><div class="line">&quot;scripts&quot;: &#123;</div><div class="line"> &quot;start&quot;: &quot;webpack-dev-server --inline --hot&quot;,</div><div class="line"> ...</div><div class="line"> &#125;</div><div class="line">// 运行： </div><div class="line">$ npm start</div><div class="line">// 浏览器预览：</div><div class="line">http://localhost:8080</div></pre></td></tr></table></figure>
</li>
<li><p>“hot” 和 “inline”功能：<br>“inline”选项会为入口页面添加“热加载”功能，“hot”选项则开启“热替换（Hot Module Reloading）”，即尝试重新加载组件改变的部分（而不是重新加载整个页面）。如果两个参数都传入，当资源改变时，webpack-dev-server将会先尝试HRM（即热替换），如果失败则重新加载整个入口页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 通过CLI传参</div><div class="line">webpack-dev-server --hot --inline</div><div class="line">// 通过webpack.config.js传参</div><div class="line">devServer: &#123;</div><div class="line">  inline: true,</div><div class="line">  hot:true</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="相关配置字段解析"><a href="#相关配置字段解析" class="headerlink" title="相关配置字段解析"></a>相关配置字段解析</h2><h3 id="1-entry"><a href="#1-entry" class="headerlink" title="1.entry"></a>1.entry</h3><p>Enter配置项告诉Webpack应用的根模块或起始点在哪里，它的值可以是字符串、数组或对象。这看起来可能令人困惑，因为不同类型的值有着不同的目的。</p>
<p>像绝大多数app一样，倘若你的应用只有一个单一的入口，enter项的值你可以使用任意类型，最终输出的结果都是一样的。</p>
<h5 id="enter：数组类型"><a href="#enter：数组类型" class="headerlink" title="enter：数组类型"></a><em>enter：数组类型</em></h5><p>你想添加多个彼此不互相依赖的文件，你可以使用数组格式的值。例如，你可能在html文件里引用了“googleAnalytics.js”文件，可以告诉Webpack将其加到bundle.js的最后。<br><img src="http://i.imgur.com/sk32RvT.png" alt=""></p>
<h5 id="enter：对象"><a href="#enter：对象" class="headerlink" title="enter：对象"></a><em>enter：对象</em></h5><p>现在，假设你的应用是多页面的（multi-page application）而不是SPA，有多个html文件（index.html和profile.html）。然后你通过一个对象告诉Webpack为每一个html生成一个bundle文件。</p>
<p>以下的配置将会生成两个js文件：indexEntry.js和profileEntry.js分别会在index.html和profile.html中被引用。<br><img src="http://i.imgur.com/U1f6dJ4.png" alt=""></p>
<h5 id="enter：混合类型"><a href="#enter：混合类型" class="headerlink" title="enter：混合类型"></a><em>enter：混合类型</em></h5><p>你也可以在enter将数组对象混用。例如下面的配置将会生成3个文件：vender.js（包含三个文件），index.js和profile.js文件。<br><img src="http://i.imgur.com/bY9wAv3.png" alt=""></p>
<h3 id="2-output"><a href="#2-output" class="headerlink" title="2.output"></a>2.output</h3><p>output项告诉webpack怎样存储输出结果以及存储到哪里。output的两个配置项“path”和“publicPath”可能会给大家造成困惑。</p>
<p>“path”仅仅告诉Webpack结果存储在哪里，然而“publicPath”项则被许多Webpack的插件用于在生产模式下更新内嵌到css、html文件里的url值。<br><img src="http://i.imgur.com/JHRGPnt.png" alt=""></p>
<p>例如，在localhost里的css文件中边你可能用“./test.png”这样的url来加载图片，但是在生产模式下“test.png”文件可能会定位到CDN上并且你的Node.js服务器可能是运行在HeroKu上边的。这就意味着在生产环境你必须手动更新所有文件里的url为CDN的路径。</p>
<p>然而你也可以使用Webpack的“publicPath”选项和一些插件来在生产模式下编译输出文件时自动更新这些url。<br><img src="http://i.imgur.com/pQJGrEz.png" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 开发环境：Server和图片都是在localhost（域名）下</div><div class="line">.image &#123; </div><div class="line">  background-image: url(&apos;./test.png&apos;);</div><div class="line"> &#125;</div><div class="line">// 生产环境：Server部署下HeroKu但是图片在CDN上</div><div class="line">.image &#123; </div><div class="line">  background-image: url(&apos;https://someCDN/test.png&apos;);</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<h3 id="3-module-amp-loaders"><a href="#3-module-amp-loaders" class="headerlink" title="3.module &amp; loaders"></a>3.module &amp; loaders</h3><h5 id="module"><a href="#module" class="headerlink" title="module"></a><em>module</em></h5><p>模块加载器是可自由添加的Node模块，用于将不同类型的文件“load”或“import”并转换成浏览器可以识别的类型，如js、Stylesheet等。更高级的模块加载器甚至可以支持使用ES6里边的“require”或“import”引入模块。</p>
<p>例如，你可以使用babel-loader来将使用ES6语法写成的文件转换成ES5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line"> loaders: [&#123;</div><div class="line">  test: /\.js$/, // 匹配.js文件，如果通过则使用下面的loader</div><div class="line">  exclude: /node_modules/, // 排除node_modules文件夹</div><div class="line">  loader: &apos;babel&apos; // 使用babel（babel-loader的简写）作为loader</div><div class="line"> &#125;]</div></pre></td></tr></table></figure></p>
<h5 id="loaders"><a href="#loaders" class="headerlink" title="loaders"></a><em>loaders</em></h5><p>loaders意为“加载器”，区分于plugins“插件”。</p>
<ul>
<li><p>链式的加载器（从右往左执行）<br>多个loader可以用在同一个文件上并且被链式调用。链式调用时从右到左执行且loader之间用“!”来分割。<br>例如，假设我们有一个名为“myCssFile.css”的css文件，然后我们想将它的内容使用style标签内联到最终输出的html里边。我们可以使用css-loader和style-loader两个loader来达到目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">module: &#123;</div><div class="line"> loaders: [&#123;</div><div class="line">  test: /\.css$/,</div><div class="line">  loader: &apos;style!css&apos; //(short for style-loader!css-loader)</div><div class="line"> &#125;]</div></pre></td></tr></table></figure>
</li>
<li><p>loader自身可以配置<br>模块加载器（loader）自身可以根据传入不同的参数进行配置。<br>在下面的例子中，我们可以配置url-loader来将小于1024字节的图片使用DataUrl替换而大于1024字节的图片使用url，我们可以用如下两种方式通过传入“limit“参数来实现这一目的：<br><img src="http://i.imgur.com/tBdakXB.png" alt=""></p>
</li>
</ul>
<h3 id="4-plugins"><a href="#4-plugins" class="headerlink" title="4.plugins"></a>4.plugins</h3><p>插件一般都是用于输出bundle的node模块。<br>例如，uglifyJSPlugin获取bundle.js然后压缩和混淆内容以减小文件体积。<br>类似的extract-text-webpack-plugin内部使用css-loader和style-loader来收集所有的css到一个地方最终将结果提取结果到一个独立的”styles.css“文件，并且在html里边引用style.css文件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">//webpack.config.js</div><div class="line">// 获取所有的.css文件，合并它们的内容然后提取css内容到一个独立的”styles.css“里</div><div class="line">var ETP = require(&quot;extract-text-webpack-plugin&quot;);</div><div class="line">module: &#123;</div><div class="line"> loaders: [</div><div class="line">  &#123;test: /\.css$/, loader:ETP.extract(&quot;style-loader&quot;,&quot;css-loader&quot;) &#125;</div><div class="line">  ]</div><div class="line">&#125;,</div><div class="line">plugins: [</div><div class="line">    new ExtractTextPlugin(&quot;styles.css&quot;) //Extract to styles.css file</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="5-resolve"><a href="#5-resolve" class="headerlink" title="5.resolve"></a>5.resolve</h3><p>很多Webpack的配置文件都有一个resolve属性，然后就像下面代码所示有一个空字符串的值。空字符串在此是为了resolve一些在import文件时不带文件扩展名的表达式，如<code>require(&#39;./myJSFile&#39;)</code>或者<code>import myJSFile from &#39;./myJSFile&#39;</code>（注：实际就是自动添加后缀，默认是当成js文件来查找路径）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line"> resolve: &#123;</div><div class="line">   extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.jsx&apos;]</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/09/19/深入了解webpack/" data-id="cit9p8s6r00002wf9dilzr1d4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/19/深入了解webpack/">深入了解webpack</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 朱宏伟<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>